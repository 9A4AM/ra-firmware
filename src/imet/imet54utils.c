
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>

#include "lpclib.h"
#include "imet54.h"
#include "imet54private.h"



static const uint8_t _imet54_hamming[256] = {
    0x00,0x00,0x00,0x80,0x00,0x80,0x80,0x01,0x00,0x80,0x80,0x08,0x80,0x05,0x03,0x80,
    0x00,0x80,0x80,0x06,0x80,0x0B,0x03,0x80,0x80,0x02,0x03,0x80,0x03,0x80,0x03,0x03,
    0x00,0x80,0x80,0x06,0x80,0x05,0x0D,0x80,0x80,0x05,0x04,0x80,0x05,0x05,0x80,0x05,
    0x80,0x06,0x06,0x06,0x07,0x80,0x80,0x06,0x0E,0x80,0x80,0x06,0x80,0x05,0x03,0x80,
    0x00,0x80,0x80,0x08,0x80,0x0B,0x0D,0x80,0x80,0x08,0x08,0x08,0x09,0x80,0x80,0x08,
    0x80,0x0B,0x0A,0x80,0x0B,0x0B,0x80,0x0B,0x0E,0x80,0x80,0x08,0x80,0x0B,0x03,0x80,
    0x80,0x0C,0x0D,0x80,0x0D,0x80,0x0D,0x0D,0x0E,0x80,0x80,0x08,0x80,0x05,0x0D,0x80,
    0x0E,0x80,0x80,0x06,0x80,0x0B,0x0D,0x80,0x0E,0x0E,0x0E,0x80,0x0E,0x80,0x80,0x0F,
    0x00,0x80,0x80,0x01,0x80,0x01,0x01,0x01,0x80,0x02,0x04,0x80,0x09,0x80,0x80,0x01,
    0x80,0x02,0x0A,0x80,0x07,0x80,0x80,0x01,0x02,0x02,0x80,0x02,0x80,0x02,0x03,0x80,
    0x80,0x0C,0x04,0x80,0x07,0x80,0x80,0x01,0x04,0x80,0x04,0x04,0x80,0x05,0x04,0x80,
    0x07,0x80,0x80,0x06,0x07,0x07,0x07,0x80,0x80,0x02,0x04,0x80,0x07,0x80,0x80,0x0F,
    0x80,0x0C,0x0A,0x80,0x09,0x80,0x80,0x01,0x09,0x80,0x80,0x08,0x09,0x09,0x09,0x80,
    0x0A,0x80,0x0A,0x0A,0x80,0x0B,0x0A,0x80,0x80,0x02,0x0A,0x80,0x09,0x80,0x80,0x0F,
    0x0C,0x0C,0x80,0x0C,0x80,0x0C,0x0D,0x80,0x80,0x0C,0x04,0x80,0x09,0x80,0x80,0x0F,
    0x80,0x0C,0x0A,0x80,0x07,0x80,0x80,0x0F,0x0E,0x80,0x80,0x0F,0x80,0x0F,0x0F,0x0F,
};



/* Deinterleave 8-byte block */
void _IMET54_deinterleave (uint8_t *block)
{
    uint8_t di[8] = {0};

    for (int i = 0; i < 8; i++) {
        for (int j = 0; j < 8; j++) {
            if (block[i] & (1u << j)) {
                di[7 - j] |= (1u << i);
            }
        }
    }
    memcpy(block, di, 8);
}


/* Check Hamming parity bits. Put the result (half of the input size) into the output buffer.
 * Length must be a multiple of two.
 */
_Bool _IMET54_checkParity (uint8_t *inBuffer, int length, uint8_t *outBuffer)
{
    bool result = true;

    if (length % 2) {
        result = false;
    } else {
        for (int i = 0; i < length; i += 2) {
            uint8_t nibble1 = _imet54_hamming[inBuffer[i+0]];
            uint8_t nibble2 = _imet54_hamming[inBuffer[i+1]];

            if ((nibble1 | nibble2) & 0x80) {
                /* Uncorrectable error */
                result = false;
                break;
            }

            outBuffer[i / 2] = (nibble2 << 4) | nibble1;
        }
    }

    return result;
}


/* Check block CRC */
_Bool _IMET54_checkCRC (
        uint8_t *buffer1, int length1,
        uint8_t *buffer2, int length2,
        uint32_t receivedCRC)
{
    CRC_Handle crc = LPCLIB_INVALID_HANDLE;
    CRC_Mode crcMode;
    bool result = false;

    crcMode = CRC_makeMode(
            CRC_POLY_CRC32,
            CRC_DATAORDER_NORMAL,
            CRC_SUMORDER_NORMAL,
            CRC_DATAPOLARITY_NORMAL,
            CRC_SUMPOLARITY_NORMAL
            );
    if (CRC_open(crcMode, &crc) == LPCLIB_SUCCESS) {
        CRC_seed(crc, 0xFFFFFFFF);
        if (buffer1) {
            CRC_write(crc, buffer1, length1, NULL, NULL);
        }
        if (buffer2) {
            CRC_write(crc, buffer2, length2, NULL, NULL);
        }

        result = receivedCRC == CRC_read(crc);

        CRC_close(&crc);
    }

    return result;
}


int _IMET54_uuencode (
    char *buf,
    int bufLength,
    const uint8_t *block1,
    int length1,
    const uint8_t *block2,
    int length2)
{
    const uint32_t N = ((length1 + length2 + 1) / 3) * 3;
    uint32_t n;
    uint8_t uu[4+1];
    uint8_t raw[3];
    int i;
    int j;
    int nWritten = 0;

    i = 0;
    for (n = 0; n < N; n += 3) {
        uu[0] = uu[1] = uu[2] = uu[3] = uu[4] = 0;

        for (j = 0; j < 3; j++) {
            if (i < length1) {
                raw[j] = *block1++;
            } else {
                if (i < length1 + length2) {
                    raw[j] = *block2++;
                } else {
                    raw[j] = 0;
                }
            }
        }

        uu[0] = raw[0] & 0x3F;
        uu[1] = ((raw[1] << 2) & 0x3C) | ((raw[0] >> 6) & 0x03);
        uu[2] = ((raw[2] << 4) & 0x30) | ((raw[1] >> 4) & 0x0F);
        uu[3] = (raw[2] >> 2) & 0x3F;

        for (j = 0; j < 4; j++) {
            uu[j] ^= 0x20;
            if (uu[j] <= 0x20) {
                uu[j] |= 0x40;
            }
            /* Deviation from UUENCODE: Avoid comma, replace by space */
            if (uu[j] == ',') {
                uu[j] = ' ';
            }
        }

        nWritten += snprintf(&buf[nWritten], bufLength - nWritten, "%s", uu);
    }

    return nWritten;
}
