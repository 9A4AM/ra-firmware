
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>

#include "lpclib.h"
#include "imet54.h"
#include "imet54private.h"



static const uint8_t _imet54_hamming[256] = {
    0x00,0x00,0x00,0x80,0x00,0x80,0x80,0x01,0x00,0x80,0x80,0x08,0x80,0x05,0x03,0x80,
    0x00,0x80,0x80,0x06,0x80,0x0B,0x03,0x80,0x80,0x02,0x03,0x80,0x03,0x80,0x03,0x03,
    0x00,0x80,0x80,0x06,0x80,0x05,0x0D,0x80,0x80,0x05,0x04,0x80,0x05,0x05,0x80,0x05,
    0x80,0x06,0x06,0x06,0x07,0x80,0x80,0x06,0x0E,0x80,0x80,0x06,0x80,0x05,0x03,0x80,
    0x00,0x80,0x80,0x08,0x80,0x0B,0x0D,0x80,0x80,0x08,0x08,0x08,0x09,0x80,0x80,0x08,
    0x80,0x0B,0x0A,0x80,0x0B,0x0B,0x80,0x0B,0x0E,0x80,0x80,0x08,0x80,0x0B,0x03,0x80,
    0x80,0x0C,0x0D,0x80,0x0D,0x80,0x0D,0x0D,0x0E,0x80,0x80,0x08,0x80,0x05,0x0D,0x80,
    0x0E,0x80,0x80,0x06,0x80,0x0B,0x0D,0x80,0x0E,0x0E,0x0E,0x80,0x0E,0x80,0x80,0x0F,
    0x00,0x80,0x80,0x01,0x80,0x01,0x01,0x01,0x80,0x02,0x04,0x80,0x09,0x80,0x80,0x01,
    0x80,0x02,0x0A,0x80,0x07,0x80,0x80,0x01,0x02,0x02,0x80,0x02,0x80,0x02,0x03,0x80,
    0x80,0x0C,0x04,0x80,0x07,0x80,0x80,0x01,0x04,0x80,0x04,0x04,0x80,0x05,0x04,0x80,
    0x07,0x80,0x80,0x06,0x07,0x07,0x07,0x80,0x80,0x02,0x04,0x80,0x07,0x80,0x80,0x0F,
    0x80,0x0C,0x0A,0x80,0x09,0x80,0x80,0x01,0x09,0x80,0x80,0x08,0x09,0x09,0x09,0x80,
    0x0A,0x80,0x0A,0x0A,0x80,0x0B,0x0A,0x80,0x80,0x02,0x0A,0x80,0x09,0x80,0x80,0x0F,
    0x0C,0x0C,0x80,0x0C,0x80,0x0C,0x0D,0x80,0x80,0x0C,0x04,0x80,0x09,0x80,0x80,0x0F,
    0x80,0x0C,0x0A,0x80,0x07,0x80,0x80,0x0F,0x0E,0x80,0x80,0x0F,0x80,0x0F,0x0F,0x0F,
};



/* Deinterleave 8-byte block */
void _IMET54_deinterleave (uint8_t *block)
{
    uint8_t di[8] = {0};

    for (int i = 0; i < 8; i++) {
        for (int j = 0; j < 8; j++) {
            if (block[i] & (1u << j)) {
                di[7 - j] |= (1u << i);
            }
        }
    }
    memcpy(block, di, 8);
}


/* Check Hamming parity bits. Put the result (half of the input size) into the output buffer.
 * Length must be a multiple of two.
 */
_Bool _IMET54_checkParity (uint8_t *inBuffer, int length, uint8_t *outBuffer)
{
    bool result = true;

    if (length % 2) {
        result = false;
    } else {
        for (int i = 0; i < length; i += 2) {
            uint8_t nibble1 = _imet54_hamming[inBuffer[i+0]];
            uint8_t nibble2 = _imet54_hamming[inBuffer[i+1]];

            if ((nibble1 | nibble2) & 0x80) {
                /* Uncorrectable error */
                result = false;
                break;
            }

            outBuffer[i / 2] = (nibble2 << 4) | nibble1;
        }
    }

    return result;
}


/* Check block CRC */
_Bool _IMET54_checkCRC (
        uint8_t *buffer1, int length1,
        uint8_t *buffer2, int length2,
        uint32_t receivedCRC)
{
    CRC_Handle crc = LPCLIB_INVALID_HANDLE;
    CRC_Mode crcMode;
    bool result = false;

    crcMode = CRC_makeMode(
            CRC_POLY_CRC32,
            CRC_DATAORDER_NORMAL,
            CRC_SUMORDER_NORMAL,
            CRC_DATAPOLARITY_NORMAL,
            CRC_SUMPOLARITY_NORMAL
            );
    if (CRC_open(crcMode, &crc) == LPCLIB_SUCCESS) {
        CRC_seed(crc, 0xFFFFFFFF);
        if (buffer1) {
            CRC_write(crc, buffer1, length1, NULL, NULL);
        }
        if (buffer2) {
            CRC_write(crc, buffer2, length2, NULL, NULL);
        }

        result = receivedCRC == CRC_read(crc);

        CRC_close(&crc);
    }

    return result;
}
