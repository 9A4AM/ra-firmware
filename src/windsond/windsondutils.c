
#include <inttypes.h>
#include <stdio.h>
#include <stdlib.h>

#include "lpclib.h"
#include "windsond.h"
#include "windsondprivate.h"



/* Whitening sequence generated by xx-position LFSR.
 * Characteristic polynomial: //TODO x^16 + x^6 + x^4 + x^2 + 1
 */
static const uint8_t whitening[64] = {
    0x0F,0x70,0xB3,0x6F,0x43,0x98,0x48,0xAE,
    0xBC,0x97,0x38,0x1D,0xD3,0xD4,0xA0,0x55,
    0x7D,0x68,0x37,0x6D,0x60,0xBB,0xE3,0xCD,
    0x35,0xC6,0x8B,0xFA,0x58,0xA6,0x30,0x19,
    0x95,0x93,0xF6,0x92,0x6F,0xCB,0x50,0xA2,
    0x76,0x5E,0xC3,0x54,0xE4,0x31,0x08,0x04,
    0x46,0x47,0x56,0xC7,0x12,0xA3,0x67,0xCF,
    0x16,0xE5,0x20,0x99,0xD1,0xF7,0x83,0xFE,
};


/* Search for correct CRC in the frame */
_Bool _WINDSOND_checkCRC (uint8_t *buffer, int length)
{
    CRC_Handle crc = LPCLIB_INVALID_HANDLE;
    CRC_Mode crcMode;
    bool result = false;

    crcMode = CRC_makeMode(
            CRC_POLY_CRCCCITT,
            CRC_DATAORDER_REVERSE,
            CRC_SUMORDER_REVERSE,
            CRC_DATAPOLARITY_NORMAL,
            CRC_SUMPOLARITY_NORMAL
            );
    if (CRC_open(crcMode, &crc) == LPCLIB_SUCCESS) {
        CRC_seed(crc, 0xFFFF);

        for (int i = 0; i < length; i++) {
            CRC_write(crc, &buffer[i], 1, NULL, NULL);
            uint16_t receivedCRC = buffer[i+1] * 256 + buffer[i+2];
            if (receivedCRC == CRC_read(crc)) {
                result = true;
                break;
            }
        }
    }

    CRC_close(&crc);

    return result;
}


/* Remove data whitening */
void _WINDSOND_removeWhitening(uint8_t *buffer, int length)
{
    int i;

    for (i = 0; i < length; i++) {
        buffer[i] ^= whitening[i % 64];
    }
}


/* Decode a single 24-bit Extended Binary Golay Codeword.
 * Follow the simple algorithm described here:
 * https://www.maplesoft.com/applications/view.aspx?SID=1757&view=html
 */
static int GOLAY_decode (uint32_t *cw, int *numcorrected)
{
    const uint32_t H[12] = {
        0x00800B71,
        0x004006E3,
        0x00200DC5,
        0x00100B8B,
        0x00080717,
        0x00040E2D,
        0x00020C5B,
        0x000108B7,
        0x0000816F,
        0x000042DD,
        0x000025B9,
        0x00001FFE,
    };

    uint32_t S;     /* Syndrome vector */
    uint32_t w;     /* Hamming weight */
    int i,j;
    uint32_t x;


    *numcorrected = 0;

    /* Determine syndromes */
    S = 0;
    for (i = 0; i < 12; i++) {
        S = 2*S + (__builtin_popcount(*cw & H[i]) % 2);
    }
    w = __builtin_popcount(S);

    /* Need for error correction? */
    if (w > 0) {
        /* If the weight of the syndrome vector is not larger than the error correction
         * capability t, S holds the error pattern of the k info bits in cw.
         */
        if (w <= 3) {
            *cw ^= (S << 12);
            *numcorrected = w;
        }
        else {
            /* Add the syndrome vector to the parity part of H. Look for a resulting
             * vector of Hamming weight 2 or below.
             */
            for (j = 0; j < 12; j++) {
                x = S ^ (H[j] & 0xFFF);
                w = __builtin_popcount(x);
                if (w <= 2) {
                    /* One error in the parity bits, and w errors in the data bits */
                    *cw ^= (x << 12) + (1u << (11 - j));
                    *numcorrected = 1 + w;
                }
            }

            /* If no correction was made yet: */
            if (*numcorrected == 0) {
                uint32_t S2 = 0;
                for (i = 0; i < 12; i++) {
                    S2 = 2*S2 + (__builtin_popcount(S & (H[i] & 0xFFF)) % 2);
                }
                w = __builtin_popcount(S2);
                if (w <= 3) {
                    *cw ^= S2;
                    *numcorrected = w;
                }
                else {
                    for (j = 0; j < 12; j++) {
                        x = S2 ^ (H[j] & 0xFFF);
                        w = __builtin_popcount(x);
                        if (w <= 2) {
                            /* One error in the data bits, and w errors in the parity bits */
                            *cw ^= x + (1u << (23 - j));
                            *numcorrected = 1 + w;
                        }
                    }
                }
            }
        }
    }

    /* After possible error correction: determine syndromes again */
    S = 0;
    for (i = 0; i < 12; i++) {
        S = 2*S + (__builtin_popcount(*cw & H[i]) % 2);
    }

    /* Success if all syndromes are zero */
    return (S == 0);
}


/* Golay error correction.
 * Return LPCLIB_SUCCESS when there is at least one valid Golay codeword in the frame.
 */
LPCLIB_Result _WINDSOND_checkFEC (uint8_t frame[], int *pNumCodewords)
{
    int numCodewords = 0;


    /* We do not know yet the actual length of the frame. Try Golay decoding format
     * the maximum possible number of codewords. Codeword decoding beyond the
     * frame end will normally fail, of course.
     * Stop Golay decoding once a codeword fails to decode.
     */
    for (int i = 0; i < (int)sizeof(WINDSOND_Packet)-1; i+=3) {
        /* A codeword is 24 bits (3 bytes) */
        uint32_t cw = (frame[i+0] << 16) | (frame[i+1] << 8) | (frame[i+2] << 0);
        int numcorrected = 0;
        if (GOLAY_decode(&cw, &numcorrected)) {
            /* Write decoded data (half the codeword length) back to the same frame buffer */
            if ((i % 2) == 0) {
                frame[(i / 2) + 0] = (cw >> 16) & 0xFF;
                frame[(i / 2) + 1] = ((cw >> 12) & 0x0F) << 4;
            }
            else {
                frame[(i / 2) + 0] |= (cw >> 20) & 0x0F;
                frame[(i / 2) + 1] = (cw >> 12) & 0xFF;
            }
            ++numCodewords;
        } else {
            /* Uncorrectable error. Stop */
            break;
        }
    }

    *pNumCodewords = numCodewords;

    return (numCodewords > 0) ? LPCLIB_SUCCESS : LPCLIB_ERROR;
}
